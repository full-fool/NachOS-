// machine.cc 
//	Routines for simulating the execution of user programs.
//
//  DO NOT CHANGE -- part of the machine emulation
//
// Copyright (c) 1992-1993 The Regents of the University of California.
// All rights reserved.  See copyright.h for copyright notice and limitation 
// of liability and disclaimer of warranty provisions.

#include "copyright.h"
#include "machine.h"
#include "system.h"
#include "noff.h"
// Textual names of the exceptions that can be generated by user program
// execution, for debugging.
static char* exceptionNames[] = { "no exception", "syscall", 
				"page fault/no TLB entry", "page read only",
				"bus error", "address error", "overflow",
				"illegal instruction" };

//----------------------------------------------------------------------
// CheckEndian
// 	Check to be sure that the host really uses the format it says it 
//	does, for storing the bytes of an integer.  Stop on error.
//----------------------------------------------------------------------

static
void CheckEndian()
{
    union checkit {
        char charword[4];
        unsigned int intword;
    } check;

    check.charword[0] = 1;
    check.charword[1] = 2;
    check.charword[2] = 3;
    check.charword[3] = 4;

#ifdef HOST_IS_BIG_ENDIAN
    ASSERT (check.intword == 0x01020304);
#else
    ASSERT (check.intword == 0x04030201);
#endif
}

//----------------------------------------------------------------------
// Machine::Machine
// 	Initialize the simulation of user program execution.
//
//	"debug" -- if TRUE, drop into the debugger after each user instruction
//		is executed.
//----------------------------------------------------------------------

Machine::Machine(bool debug)
{
    int i;

    for (i = 0; i < NumTotalRegs; i++)
        registers[i] = 0;
    mainMemory = new char[MemorySize];
    //memset(mainMemory, 0, sizeof mainMemory);
    for (i = 0; i < MemorySize; i++)
      	mainMemory[i] = 0;
    //printf("memory is initialized and MemorySize is %d\n", MemorySize);
//#ifdef USE_TLB
    tlb = new TranslationEntry[TLBSize];
    for (i = 0; i < TLBSize; i++)
    {
        tlb[i].valid = FALSE;
        tlb[i].hitTimes = 0;
        tlb[i].order = i;
        tlb[i].dirty = FALSE;
    }
    pageTable = NULL;
//#else	// use linear page table
//    tlb = NULL;
//    pageTable = NULL;
//#endif

    singleStep = debug;
    CheckEndian();
}

//----------------------------------------------------------------------
// Machine::~Machine
// 	De-allocate the data structures used to simulate user program execution.
//----------------------------------------------------------------------

Machine::~Machine()
{
    delete [] mainMemory;
    if (tlb != NULL)
        delete [] tlb;
}

//----------------------------------------------------------------------
// Machine::RaiseException
// 	Transfer control to the Nachos kernel from user mode, because
//	the user program either invoked a system call, or some exception
//	occured (such as the address translation failed).
//
//	"which" -- the cause of the kernel trap
//	"badVaddr" -- the virtual address causing the trap, if appropriate
//----------------------------------------------------------------------

void
Machine::RaiseException(ExceptionType which, int badVAddr)
{
    DEBUG('m', "Exception: %s\n", exceptionNames[which]);
    //printf("in RaiseException, exceptiontype is %d and badVAddr is %d\n", which, badVAddr);
//  ASSERT(interrupt->getStatus() == UserMode);
    registers[BadVAddrReg] = badVAddr;
    DelayedLoad(0, 0);			// finish anything in progress
    interrupt->setStatus(SystemMode);
    ExceptionHandler(which);		// interrupts are enabled at this point
    interrupt->setStatus(UserMode);
    //printf("RaiseException returns here \n");
}

//----------------------------------------------------------------------
// Machine::Debugger
// 	Primitive debugger for user programs.  Note that we can't use
//	gdb to debug user programs, since gdb doesn't run on top of Nachos.
//	It could, but you'd have to implement *a lot* more system calls
//	to get it to work!
//
//	So just allow single-stepping, and printing the contents of memory.
//----------------------------------------------------------------------

void Machine::Debugger()
{
    char *buf = new char[80];
    int num;
    //printf("reach debugger!\n");
    interrupt->DumpState();
    DumpState();
    printf("%d> ", stats->totalTicks);
    fflush(stdout);
    fgets(buf, 80, stdin);
    if (sscanf(buf, "%d", &num) == 1)
	runUntilTime = num;
    else {
	runUntilTime = 0;
	switch (*buf) {
	  case '\n':
	    break;
	    
	  case 'c':
	    singleStep = FALSE;
	    break;
	    
	  case '?':
	    printf("Machine commands:\n");
	    printf("    <return>  execute one instruction\n");
	    printf("    <number>  run until the given timer tick\n");
	    printf("    c         run until completion\n");
	    printf("    ?         print help message\n");
	    break;
	}
    }
    delete [] buf;
}
 
//----------------------------------------------------------------------
// Machine::DumpState
// 	Print the user program's CPU state.  We might print the contents
//	of memory, but that seemed like overkill.
//----------------------------------------------------------------------

void
Machine::DumpState()
{
    int i;
    
    printf("Machine registers:\n");
    for (i = 0; i < NumGPRegs; i++)
	switch (i) {
	  case StackReg:
	    printf("\tSP(%d):\t0x%x%s", i, registers[i],
		   ((i % 4) == 3) ? "\n" : "");
	    break;
	    
	  case RetAddrReg:
	    printf("\tRA(%d):\t0x%x%s", i, registers[i],
		   ((i % 4) == 3) ? "\n" : "");
	    break;
	  
	  default:
	    printf("\t%d:\t0x%x%s", i, registers[i],
		   ((i % 4) == 3) ? "\n" : "");
	    break;
	}
    
    printf("\tHi:\t0x%x", registers[HiReg]);
    printf("\tLo:\t0x%x\n", registers[LoReg]);
    printf("\tPC:\t0x%x", registers[PCReg]);
    printf("\tNextPC:\t0x%x", registers[NextPCReg]);
    printf("\tPrevPC:\t0x%x\n", registers[PrevPCReg]);
    printf("\tLoad:\t0x%x", registers[LoadReg]);
    printf("\tLoadV:\t0x%x\n", registers[LoadValueReg]);
    printf("\n");
}

//----------------------------------------------------------------------
// Machine::ReadRegister/WriteRegister
//   	Fetch or write the contents of a user program register.
//----------------------------------------------------------------------

int Machine::ReadRegister(int num)
    {
	ASSERT((num >= 0) && (num < NumTotalRegs));
	return registers[num];
    }

void Machine::WriteRegister(int num, int value)
    {
	ASSERT((num >= 0) && (num < NumTotalRegs));
	// DEBUG('m', "WriteRegister %d, value %d\n", num, value);
	//printf("in WriteRegister, %d written into registers %d\n", value, num);
    registers[num] = value;
    }

bool Machine::TlbSwap(int virtualAddr, int choose)
{
    //printf("tlb swap happened here on virtualAddr %d\n", virtualAddr);
    ASSERT(tlb != NULL);
    int vpn = (unsigned) virtualAddr / PageSize;
    ASSERT(vpn < pageTableSize);
    if(pageTable[vpn].valid == FALSE)
    {
        LoadPage(virtualAddr);
    }
    ASSERT(pageTable[vpn].valid == TRUE);

    if(choose == 1)
    {
        int minHit = 2147483647;
        int minNum = 0;
        for(int i=0; i<TLBSize; i++)
        {
            //printf("in tlbswap, tlb[%d] hitTimes is %d\n", i, tlb[i].hitTimes);
            if(tlb[i].hitTimes < minHit)
            {
                minHit = tlb[i].hitTimes;
                minNum = i;
            }
        }
       
        ASSERT(minNum >= 0 && minNum < TLBSize);
        
        for (int i = 0; i < TLBSize; i++)
        {
            if (tlb[i].physicalPage == pageTable[vpn].physicalPage)
            {
                tlb[i].hitTimes = 0;
                tlb[i].valid = FALSE;
            }
        }
        
            

        tlb[minNum].virtualPage = vpn;

        tlb[minNum].physicalPage = pageTable[vpn].physicalPage;
        //printf("tlb[%d] is swapped out, new vpn is %d and new physicalPage is %d\n", minNum, vpn, 
        //    tlb[minNum].physicalPage);
        tlb[minNum].valid = TRUE;        
        tlb[minNum].readOnly = FALSE;
        tlb[minNum].use = FALSE;
        tlb[minNum].dirty = FALSE;
        tlb[minNum].hitTimes = 1;

        return TRUE;

    }
    
    else if(choose == 2)
    {
        //srand((unsigned)time(NULL));
        //int toSwap = rand() % TLBSize;
        int toSwap = -1;
        for(int i=0; i<TLBSize; i++)
        {
            if(tlb[i].order == 0)
            {
                toSwap = i;
                break;
            }
        }
            
        ASSERT(toSwap >= 0);
        ASSERT(vpn < pageTableSize && pageTable[vpn].valid == TRUE);
        tlb[toSwap].virtualPage = vpn;
        tlb[toSwap].physicalPage = pageTable[vpn].physicalPage;
        tlb[toSwap].valid = TRUE;
        tlb[toSwap].readOnly = FALSE;
        tlb[toSwap].use = TRUE;
        tlb[toSwap].dirty = FALSE;
        tlb[toSwap].hitTimes = 0;
        for(int i=0; i<TLBSize; i++)
        {
            tlb[i].order -= 1;
        }
        tlb[toSwap].order = TLBSize - 1;
        return true;
    }
    
    ASSERT(FALSE)

    //printf("tlb swap returns here\n"); 
}





bool 
Machine::LoadPage(int virtualAddr)
{
    NoffHeader noffH;
    
    AddrSpace *space = currentThread->space;

    //load page from this space
    int vpn = virtualAddr / PageSize;
    int startVAddr = vpn * PageSize;
    //printf("pageTableSize is %d, vpn is %d, pageTable[vpn].valid is %d\n",
    //   pageTableSize, vpn, pageTable[vpn].valid);
    ASSERT(vpn < pageTableSize);
    ASSERT(!pageTable[vpn].valid);              //assert that this page is invalid
    int minVirPage = -1;
    int minHitTimes = 2147483647;

    //if a physical page is invalid,
    int pageToBeReplaced = -1;
    int phyPageNum;

    OpenFile *diskFile = space->swapFile;
    if(diskFile == NULL)
        printf("!!!!could not open diskFile!!!!\n");

   

    //in this case, page replacement is not necessary
    for(int i=0; i<pageTableSize; i++)
    {
        if(pageTable[i].valid && pageTable[i].hitTimes < minHitTimes)
        {
            minHitTimes = pageTable[i].hitTimes;
            minVirPage = i;
        }
    }
    ASSERT(minVirPage >= 0 && minVirPage < pageTableSize);
    pageToBeReplaced = minVirPage;



    //write back anyway
    phyPageNum = pageTable[pageToBeReplaced].physicalPage;
    diskFile->WriteAt(&(mainMemory[phyPageNum * PageSize]), PageSize, 
        pageTable[pageToBeReplaced].virtualPage * PageSize);   
    

    pageTable[pageToBeReplaced].valid = FALSE;
    pageTable[vpn].virtualPage = vpn;
    pageTable[vpn].physicalPage = pageTable[pageToBeReplaced].physicalPage;
    pageTable[vpn].valid = TRUE;
    pageTable[vpn].use = FALSE;
    pageTable[vpn].dirty = FALSE;
    pageTable[vpn].readOnly = FALSE;  
    pageTable[vpn].hitTimes = 1;
    //printf("page Table entry %d is swapped out , and entry %d is swapped in \n",pageToBeReplaced, vpn );
    
    phyPageNum = pageTable[vpn].physicalPage;
    diskFile->ReadAt(&(machine->mainMemory[phyPageNum * PageSize]), PageSize, vpn * PageSize); 

    //space->RestoreState();  
}

bool
Machine::AddPC()
{
    WriteRegister(PrevPCReg, machine->ReadRegister(PCReg));
    WriteRegister(PCReg, machine->ReadRegister(NextPCReg));
    WriteRegister(NextPCReg, machine->ReadRegister(NextPCReg) + sizeof(int));
}

void 
Machine::cleanTlb()
{
    for (int i = 0; i < TLBSize; i++)
    {
        tlb[i].valid = FALSE;
        tlb[i].hitTimes = 0;
        tlb[i].order = i;
        tlb[i].dirty = FALSE;
    }
}


